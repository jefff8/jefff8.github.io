<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小程序设计下拉筛选功能]]></title>
    <url>%2F2018%2F12%2F27%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%8B%E6%8B%89%E7%AD%9B%E9%80%89%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[需求：按照设计图，设计一个下拉筛选功能技术：微信小程序框架设计图： 一、设计布局原则：按照设计图给的参数进行设计技术：布局使用flex盒子，使用原因简便、完整、响应式地实现各种页面布局，而且基本得到所有浏览器支持布局： 二、动画效果小程序官方文档已经提供动画的api，只需要查看文档调用 实现箭头旋转（每次点击时旋转180°） 123456789101112131415161718192021222324//创建动画var animation = wx.createAnimation(&#123; duration: 500, timingFunction: "ease"&#125;)this.animation = animation;// rotate动画角度旋转if (nowShow) &#123; animation.rotate(0).step(); this.setData(&#123; animationData: animation.export() &#125;)&#125; else &#123; animation.rotate(180).step(); this.setData(&#123; animationData: animation.export() &#125;)&#125;// 切换this.setData(&#123; nowShow_city: !nowShow,&#125;) 平移变换我们只需要每次监听到点击时，添加一个样式 123456789101112131415&lt;view class="select-list &#123;&#123;selectOpen ? 'sliddown' : ''&#125;&#125;" hidden="&#123;&#123;hideOption&#125;&#125;" &gt;&lt;/view&gt;// css3 平移效果@keyframes sliddown &#123; from &#123; transform: translateY(-100%); &#125; to &#123; transform: translateY(0%); &#125;&#125;.sliddown &#123; animation: sliddown 0.2s ease-in both;&#125; 效果： 三、固定位置 通常我们滚动超过设定距离位置时，下拉view会固定在顶部以便于再次点击筛选。我们可以使用小程序scroll-view组件（由于scroll-view必须设置高度，但又无法确定高度时，可以设置page和scroll-view的height：100%） 1234567891011121314151617181920212223242526272829303132&lt;scroll-view class="scroll" scroll-y="&#123;&#123;true&#125;&#125;" bindscroll="scrollTopFun" scroll-top="&#123;&#123;scrollTop&#125;&#125;"&gt;&lt;!--需要固定的view--&gt; &lt;view class="&#123;&#123;top&gt;185 ? 'view1-fixed': 'view1'&#125;&#125;" catchtouchmove="&#123;&#123;view1_stopmove&#125;&#125;"&gt;&lt;/view&gt;&lt;/scroll-view&gt;// 滚动条触发事件scrollTopFun: function (e) &#123; this.setData(&#123; top: e.detail.scrollTop &#125;) if (e.detail.scrollTop &gt; 185) &#123; this.setData(&#123; viewShow: true &#125;) &#125; else &#123; this.setData(&#123; viewShow: false &#125;) &#125;&#125;.view1-fixed &#123; position: fixed; top: 0; background-color: #fff; display: flex; height: 44px; width: @width; justify-content: center; align-items: center;&#125; 点击选择时，页面滚动到设定距离位置并且下拉view固定到顶部只需监听点击事件中改变scrollTop值 1&lt;scroll-view scroll-top="&#123;&#123;scrollTop&#125;&#125;"&gt;&lt;/scroll-view&gt; 效果： 四、遮罩效果每次触发添加一个遮罩块，样式可自行调增123456789101112&lt;view class="mask" hidden='&#123;&#123;maskflag&#125;&#125;' bindtap="close_menu" catchtouchmove="preventTouchMove"&gt;&lt;/view&gt;.mask &#123; position: fixed; bottom: 0; left: 0; width: 100%; height: 28.5%; background-color: black; z-index: 1001; opacity: 0.50;&#125; 效果： 五、防止页面穿透滚动在测试时，滚动市区选项时，页面也跟着滚动，这样体验效果很不好，所以需要阻止页面穿透滚动 在点击触发块view添加position: fixed在可以滚动菜单位置都加上catchtouchmove阻止滚动 六、二级联动市与区选择创建本地json数据使用data-存放数据（data-index=”“）获取设置索引值比对索引添加高亮样式效果： mission complete！！！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改element源码]]></title>
    <url>%2F2018%2F12%2F14%2F%E4%BF%AE%E6%94%B9element%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[项目：mes系统需求：下拉多选筛选表格数据并且能够输入筛选下拉的数据（动态数据）技术：选用Element UI问题：Element UI里面的table组件不满足输入筛选下拉的数据 一、克隆element修改element源码不能直接在项目包组件里修改，所以需要以下步骤： 克隆element到本地 1git clone https://github.com/ElemeFE/element cd到element目录然后npm install（安装依赖） 组件源码在packages文件夹内，查找相应组件修改 修改完毕后，运行npm run dist 打包生成一个lib文件夹 最后将lib文件夹替换到项目element-ui里的lib文件夹 二、table组件element里面找到table带有筛选的组件，里面基本满足多选筛选表格数据，但是缺少输入筛选下拉的数据效果： 三、添加input输入筛选考虑到动态数据的数据比较多，所以对于表格下拉筛选一个个找这样不太友好，影响工作效率组件路径：element/packages/table/src/filter-panel.vue源码： 12345678910111213141516171819202122232425262728293031323334353637&lt;div class="el-table-filter__content"&gt; &lt;el-scrollbar wrap-class="el-table-filter__wrap"&gt; &lt;!-- 添加input框位置 --&gt; &lt;input v-model='search' /&gt; &lt;el-checkbox-group class="el-table-filter__checkbox-group" v-model="filteredValue"&gt; &lt;el-checkbox v-for="filter in filters" :key="filter.value" :label="filter.value"&gt;&#123;&#123; filter.text &#125;&#125;&lt;/el-checkbox&gt; &lt;/el-checkbox-group&gt; &lt;/el-scrollbar&gt;&lt;/div&gt;data() &#123; return &#123; table: null, cell: null, column: null, search: '' // 存放search值 &#125;;&#125;,computed: &#123; filters() &#123; let myfilters = this.column.filters; let _search = this.search; // 监听input输入框 if (_search) &#123; return myfilters.filter(function(myfilter) &#123; return Object.keys(myfilter).some(function(key) &#123; // 返回一个字符串,字符串中的字母被转换为小写字母,返回存在字符串 return String(myfilter[key]).toLowerCase().indexOf(_search) &gt; -1; &#125;); &#125;); &#125; return this.column &amp;&amp; this.column.filters; &#125;&#125; 用到的一些方法： filter()：为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组 Object.keys()，输出对象所有属性例如： 12var obj = &#123;'a': 'Beijing', 'b': 'Haidian'&#125;;console.log(Object.keys(obj)); //['a', 'b'] es6 some()some翻译为一些，所以some方法 只要其中一个为true 就会返回true的 效果：mission complete！！！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[说说web文件上传]]></title>
    <url>%2F2018%2F09%2F23%2Fweb%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[前言：运行一些实例对以前使用过的一些web文件上传方式总结一下顺带加深理解。 form表单上传 ajax上传 html5(uploader api)上传 插件上传（没用过没有发言权） 一、form表单上传：from表单上传基本是最传统的方式，使用form表单input标签内加入type=”file”控件，即可打开系统文件选择对话框，选择文件并上传。实现效果：html代码：12345678910&lt;div id="container"&gt; &lt;form method="POST" action="FileUpload.php" enctype="multipart/form-data"&gt; &lt;input id="addFile" name="file[]" type="file" multiple="multiple" accept="image/*" onchange="preview(this.files)" /&gt; &lt;br /&gt; &lt;input type="submit" value="form表单上传"&gt; &lt;/form&gt; &lt;h2&gt;图片预览:&lt;/h2&gt; &lt;div id="imgsPreview"&gt;&lt;/div&gt; &lt;button onclick="deleteImage()"&gt;清空删除&lt;/button&gt;&lt;/div&gt; form上传需要注意的几点： 上传方法method必须是post。 form表单的enctype必须是multipart/form-data。（enctype属性规定在发送到服务器之前应该如何对表单数据进行编码。默认地，表单数据会编码为”application/x-www-form-urlencoded”。就是说，在发送到服务器之前，所有字符都会进行编码（空格转换为 “+”加号，特殊符号转换为 ASCII HEX 值）。 action值为上传服务器端url处理地址。 多文件上传需要使用name=”file[]”以及添加multiple=”multiple”属性。 accept属性是HTML5的新属性，可规定通过文件上传的类型。 关于图片预览方法： FileReader window.URL.createObjectURL（为例）js代码：123456789101112var fileArr = [];var imgsPreview = document.getElementById("imgsPreview");// 图片预览function preview(files) &#123; var imgs_length = files.length; for(var i=0;i&lt;imgs_length;i++)&#123; fileArr.push(files[i]); imgsPreview.innerHTML += "&lt;img id='img" + i + "' class='images' /&gt;" var img_id = document.getElementById("img" + i); img_id.src = window.URL.createObjectURL(files[i]); &#125;&#125; window.URL.createObjectURL：创建一个新的对象URL,该对象URL可以代表某一个指定的File对象或Blob对象。 语法：1objectURL = window.URL.createObjectURL(blob); blob参数是一个File对象或者Blob对象。 objectURL是生成的对象URL.通过这个URL,可以获取到所指定文件的完整内容。 清空预览图片js代码：12345678//清空预览图片function deleteImage() &#123; // 移除图片控件输入内容 var file = $("#addFile") file.after(file.clone().val("")); file.remove(); imgsPreview.innerHTML = '';&#125; form上传对于单个预览文件的删除比较难以实现或者说实现效果不太理想，所以这里采用一次清空效果。 php代码：123456789101112131415161718192021222324252627282930313233&lt;?php foreach($_FILES as $file) &#123; $fileNum = count($file['name']); for($i=0;$i&lt;$fileNum;$i++)&#123; // 判断文件类型大小 if( ( ($file['type'][$i] == 'image/gif') || ($file['type'][$i] == 'image/png') || ($file['type'][$i] == 'image/jpg') || ($file['type'][$i] == 'image/jpeg') &amp;&amp; ($file['size'][$i] &lt; 8000000)) )&#123; if(file_exists("upload/" . $file['name'][$i]))&#123; echo $file['name'][$i] . " 文件已经存在。 "; &#125;else&#123; /** * $_FILES["file"]["name"] - 被上传文件的名称 * $_FILES["file"]["type"] - 被上传文件的类型 * $_FILES["file"]["size"] - 被上传文件的大小，以字节计 * $_FILES["file"]["tmp_name"] - 存储在服务器的文件的临时副本的名称 * $_FILES["file"]["error"] - 由文件上传导致的错误代码 */ $files[$i]['name']=$file['name'][$i]; $files[$i]['type']=$file['type'][$i]; $files[$i]['tmp_name']=$file['tmp_name'][$i]; $files[$i]['error']=$file['error'][$i]; $files[$i]['size']=$file['size'][$i]; // 分割出每个上传文件的类型 $fileType = explode("/",$files[$i]['type']); // 使用时间戳作为命名 move_uploaded_file($files[$i]["tmp_name"], "upload/" . time().".".$fileType[1]); echo "文件存储在: " . "upload/" . $files[$i]["name"]; &#125; &#125;else&#123; echo $file['name'][$i] . " 上传错误或文件格式有误 " . $file['type'][$i]; &#125; &#125; &#125;?&gt; 二、ajax上传ajax无刷新方式上传，本质与form表单上传无异，只是把表单里的内容提出来利用ajax提交，并由前端决定请求结果回传后的展示效果。（这里主要是ajax+FormData+JQ）FormData：用一些键值对来模拟一系列表单控件，即把form中所有表单元素的name与value组装成一个queryString，异步上传二进制文件。FormData对象的操作方法：效果：代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;p&gt;&lt;input type="file" id="upfile" multiple="multiple"/&gt;&lt;/p&gt;&lt;p&gt;&lt;input type="button" id="upJQuery" value="用jQuery上传" /&gt;&lt;/p&gt;&lt;div id="file_list"&gt;&lt;/div&gt;document.getElementById("upfile").addEventListener("change",function()&#123; var file_list = document.getElementById("file_list"); my_files = document.getElementById("upfile").files; for(i=0;i&lt;my_files.length;i++)&#123; self_id = Math.round(Math.random()*1000); //生成随机id my_files[i].id = self_id; fd.append(self_id,my_files[i]); //添加数据（append(key,value)） var img_src = window.URL.createObjectURL(my_files[i]); file_list.innerHTML += '&lt;div id="'+self_id+'"&gt;&lt;img src='+img_src+' class="img_preview" /&gt;&lt;span&gt;'+my_files[i].name+'&lt;/span&gt;&amp;nbsp;&lt;em&gt;（'+bytesToSize(my_files[i].size)+'）&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt;&lt;button onclick="del_file(\''+self_id+'\')"&gt;删除&lt;/button&gt;&lt;div class="progress"&gt;&lt;div class="progress-bar" style="width: 0%"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;'; var tmp_div = document.getElementById(self_id); &#125;&#125;);// 删除预览filefunction del_file(id_str)&#123; // alert(id_str); fd.delete(id_str); // delete(key) $("#"+id_str).remove(); &#125;// ajax上传$('#upJQuery').on("click",function()&#123; $.ajax(&#123; url:"test_ajax.php", type:"POST", processData:false, contentType:false, data:fd, success:function(d)&#123; alert('上传成功！'); &#125; &#125;);&#125;);// php:foreach($_FILES as $key =&gt; $value)&#123; $destination = 'up_tmp/'.time().$value['name']; move_uploaded_file($value['tmp_name'],$destination);&#125; 三、html5(uploader api)上传 （移动端）Uploader模块管理网络上传任务，用于从本地上传各种文件到服务器，并支持跨域访问操作。通过plus.uploader可获取上传管理对象。Uploader上传使用HTTP的POST方式提交数据，数据格式符合Multipart/form-data规范，即rfc1867（Form-based File Upload in HTML）协议。效果： 前端使用的是mui框架代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;header class="mui-bar mui-bar-nav"&gt; &lt;a class="mui-action-back mui-icon mui-icon-left-nav mui-pull-left"&gt;&lt;/a&gt; &lt;h1 class="mui-title" id="refresh"&gt;h5文件上传&lt;/h1&gt;&lt;/header&gt;&lt;div class="mui-content"&gt; &lt;img id="addFiles" src="images/iconfont-tianjia.png" style="width:50px;height:50px;" /&gt; &lt;/div&gt;&lt;div id=""&gt; &lt;img id="myIMG" src="" style="width: 100px;height: 100px;"/&gt;&lt;/div&gt;&lt;script type="text/javascript" charset="utf-8"&gt; mui.init(); var vConsole = new VConsole(); mui.plusReady(function()&#123; var addFiles = document.getElementById("addFiles"); var refresh = document.getElementById("refresh"); refresh.addEventListener('tap',function () &#123; window.location.reload(); &#125;); addFiles.addEventListener('tap',function () &#123; galleryImgs(); &#125;); &#125;); //相册多选照片 function galleryImgs()&#123; // 从相册中选择图片 plus.gallery.pick( function(path)&#123; for(var i=0 in path.files)&#123; paths = path.files[i]; plus.io.resolveLocalFileSystemURL( paths, function ( entry ) &#123; upload(entry.toLocalURL(),entry); &#125;, function ( e ) &#123;// alert("读取拍照文件错误："+e.message); &#125; ); &#125; &#125;, function ( e ) &#123; &#125;,&#123;filter:"image",multiple:true,system:false&#125;); &#125; //处理文件上传 function upload(path,entry)&#123; var server = "http://192.168.0.112:8082/web-upload/h5Upload.php"; var myIMG = document.getElementById("myIMG"); myIMG.src = path; var task = plus.uploader.createUpload(server,&#123; method: "POST" &#125;,function (t, status) &#123; // 上传完成 if (status == 200) &#123; alert("Upload success");// console.log(t); &#125; else &#123; alert("Upload failed: " + status); &#125; &#125; ); task.addFile(path, &#123; key: "path" &#125;);// task.addData("string", value); task.start(); &#125;&lt;/script&gt;&lt;!-- php --&gt;&lt;?php $img_url = $_FILES["path"]; $filesName=time(); $root_directory=dirname(__FILE__); //获取服务器路径 $files=$root_directory."/upload/".$filesName.".jpg"; //确定图片文件位置及名称 move_uploaded_file($img_url['tmp_name'],$files);?&gt; 四、插件上传当上传的需求要求可预览、显示上传进度、中断上传过程、大文件分片上传等等，这时传统的表单上传很难实现这些功能，我们可以借助现有插件完成。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈常见页面布局]]></title>
    <url>%2F2018%2F08%2F18%2F%E6%B5%85%E8%B0%88%E5%B8%B8%E8%A7%81%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[前言：因为深知前端布局的重要性，所以写一篇由一个布局设计的题目延伸出前端的几种常见页面布局方式，通过实践与查阅相关资料，加深对于css的布局的理解，之后再分别单独详细说明各个布局。 一、题目： 二、解决方案常见页面布局解决方案： 浮动 绝对定位 flex布局 table-cell表格布局 grid网格布局 实现效果：（中间div能够自适应宽度） 三、方案实践1.浮动什么是浮动：在我们布局的时用到的一种技术，能够方便我们进行布局，通过让元素浮动，我们可以使元素在水平上左右移动，再通过margin属性调整位置。浮动原理：使当前元素脱离普通流，相当于浮动起来一样，浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘。代码：123456789101112131415161718192021222324252627&lt;style&gt; html * &#123; padding: 0; margin: 0; &#125; .container div &#123; min-height: 100px; &#125; .left &#123; width: 300px; float: left; background-color: #15A0F5; &#125; .center &#123; background-color: #FFBBAA; &#125; .right &#123; width: 300px; float: right; background-color: #FFDD00; &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt; &lt;div class="center"&gt;浮动方案&lt;/div&gt;&lt;/div&gt; 优点： 在图片周围包含文字 创建网页布局 缺点： 因为浮动是脱离文档流，需要清除浮动，若处理不好带来很多问题（局限性） 无法撑起父元素 同级别的兄弟元素会围绕在周围 2.绝对定位定义：对象将脱离文档流，不再占据元素在文档中的正常位置。它的偏移位置是以最近已定位的祖先元素作为参照，如果没有已定位的祖先元素，则以顶级元素作为参照。代码：123456789101112131415161718192021222324252627282930&lt;style&gt; html * &#123; padding: 0; margin: 0; &#125; .container div &#123; position: absolute; min-height: 100px; &#125; .left &#123; width: 300px; left: 0; background-color: #15A0F5; &#125; .center &#123; left: 300px; right: 300px; background-color: #FFBBAA; &#125; .right &#123; width: 300px; right: 0; background-color: #FFDD00; &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="center"&gt;绝对定位方案&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt; 优点： 快捷且不容易出问题（一般父级元素使用相对定位，子元素使用绝对定位） 缺点： 因布局已脱离文档流，子元素都脱离文档流，导致可使用性比较差 3.flex布局（推荐）定义：Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。代码：1234567891011121314151617181920212223242526272829&lt;style&gt; html * &#123; padding: 0; margin: 0; &#125; .container &#123; display: flex; &#125; .container div &#123; min-height: 100px; &#125; .left &#123; width: 300px; background-color: #15A0F5; &#125; .center &#123; flex: 1; background-color: #FFBBAA; &#125; .right &#123; width: 300px; background-color: #FFDD00; &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="center"&gt;flex布局方案&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt; 优点： 简便、完整、响应式地实现各种页面布局（布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。） 兼容性好（目前已经得到所有浏览器支持） 缺点：暂时未知 4.table-cell表格布局网上争议：使用表格布局一直是一个敏感的主题。一般情况下，Web开发人员考虑基于表格布局是禁忌。尽管反对的理由看起来证据很充分，但是大多数开发者除了谴责基于表格的布局，都无法提供完善的使用场景。本人也很少使用表格布局，对此不太了解。代码：123456789101112131415161718192021222324252627282930&lt;style&gt; html * &#123; padding: 0; margin: 0; &#125; .container &#123; width: 100%; height: 100px; display: table; &#125; .container div &#123; display: table-cell; &#125; .left &#123; width: 300px; background-color: #15A0F5; &#125; .center &#123; background-color: #FFBBAA; &#125; .right &#123; width: 300px; background-color: #FFDD00; &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="center"&gt;table布局方案&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt; 优点： 在某些场合，使用Table是100%的适合、恰当和正确。比如，用table做表格是完全正确的。 缺点（主要）： table对对于页面布局来说，从语义上看是不正确的。(它描述的是表现，而不是内容。) table代码会让阅读者抓狂。(不但无法利用CSS，而且会你不知所云) table一旦设计完成就变成死的，很难通过CSS让它展现新的面貌 Tablle会阻挡浏览器渲染引擎的渲染顺序。(会延迟页面的生成速度，让用户等待更久的时间。) Table要比其它html标记占更多的字节。(延迟下载时间，占用服务器更多的流量资源。) 5.grid网格布局（技术较新）介绍：CSS Grid(网格) 布局使我们能够比以往任何时候都可以更灵活构建和控制自定义网格。 Grid(网格) 布局使我们能够将网页分成具有简单属性的行和列。它还能使我们在不改变任何HTML的情况下，使用 CSS 来定位和调整网格内的每个元素。它允许 HTML 纯粹作为内容的容器。HTML 结构不再受限于样式表现，比如不要为了实现某种布局而多次嵌套，现在这些都可以让 CSS 来完成。代码：1234567891011121314151617181920212223242526&lt;style&gt; html * &#123; padding: 0; margin: 0; &#125; .container &#123; display: grid; width: 100%; grid-template-rows: 100px; //允许我们指定网格中的行数及行的高度 grid-template-columns: 300px auto 300px; //允许我们指定网格中的列数及列的宽度 &#125; .left &#123; background-color: #15A0F5; &#125; .center &#123; background-color: #FFBBAA; &#125; .right &#123; background-color: #FFDD00; &#125;&lt;/style&gt;&lt;div class="container"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="center"&gt;grid网格布局方案&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt; 优点： 灵活性好 代码量少 缺点： 兼容性不太友好（暂时只支持高版本的浏览器）]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[去哪儿网项目实战]]></title>
    <url>%2F2018%2F08%2F12%2F%E5%8E%BB%E5%93%AA%E5%84%BF%E7%BD%91%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[前言：&emsp;这是一篇使用vue前端框架从入门到实战的学习记录，内容主要是项目中所使用的技术与遇到的问题，来不及解释了直接来吧！ 一、创建项目&emsp;默认已安装好node.js环境&emsp;关于ESlint的语法提示机制是否使用个人感觉还是根据个人编写代码风格习惯而定。本人在刚开始开发过程中尝试使用会报出很多格式上的错误警告，对于开发效率有了一定影响，最后决定统一使用Vetur插件来格式化代码，暂时还是觉得不错的。 关闭ESlint语法提示如果在新建项目时，已经打开了ESlint，但是又不想使用可在项目配置文件中注释关闭 二、项目目录结构在刚开始使用webpack构建项目的时候，不太清楚项目文件夹的结构，所以先对文件夹进行一定的了解。 三、插件库1.轮播图（vue-awesome-swiper）效果：安装：1npm install vue-awesome-swiper --save 使用：安装完成后需要在main.js文件中引入123import VueAwesomeSwiper from 'vue-awesome-swiper'import 'swiper/dist/css/swiper.css' //轮播图样式Vue.use(VueAwesomeSwiper) 2.FastClick&emsp;官方解释：移动设备上的浏览器默认会在用户点击屏幕大约延迟300毫秒后才会触发点击事件，这是为了检查用户是否在做双击。为了能够立即响应用户的点击事件，才有了FastClick。 安装：1npm install fastclick 使用：main.js中全局引入 12import fastclick from 'fastclick'fastclick.attach(document.body) 3.reset.css安装：1npm install --save reset-css 使用：main.js引入1import 'styles/reset.css' &emsp;在进行页面开发的时候，为了让页面获得浏览器跨浏览器的兼容性，需要用重置文件css代码覆盖浏览器默认的样式来统一样式。&emsp;rem：根据html的font-size大小来变化，正是基于这个出发，我们可以在每一个设备下根据设备的宽度设置对应的html字号，从而实现了自适应布局。4.border.css&emsp;统一的边框样式5.iconfont.css&emsp;引用阿里图标库，可自行选择合适的图标打包下载。6.better-scroll（滚动条）&emsp;better-scroll是一个插件，旨在解决移动端的滚动环境（已经支持PC）。核心受到iscroll实现的启发，因此更好滚动的API总体上与iscroll兼容。更重要的是，更好的滚动还扩展了一些功能，并根据iscroll优化了性能。安装：1npm install better-scroll --save 使用：在组件上引入12345import Bscroll from "better-scroll";//初始化mounted() &#123; this.scroll = new Bscroll(this.$refs.wrapper);&#125; 7.axios&emsp;Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。安装：1npm install axios --save 使用：在项目config/index.js文件中配置api接口axios请求数据123456789101112131415import axios from 'axios' // 引入axios请求// 举例axios获取城市列表数据methods: &#123; getCityInfo() &#123; axios.get("/api/city.json").then(this.getCityInfoSucc); &#125;, getCityInfoSucc(res) &#123; res = res.data; if (res.ret &amp;&amp; res.data) &#123; const data = res.data; this.hotCities = data.hotCities; this.cities = data.cities; &#125; &#125;&#125; 8.Vuex&emsp;Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。使用原因：&emsp;对于问题一，传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。&emsp;对于问题二，我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。&emsp;因此，我们为什么不把组件的共享状态抽取出来，以一个全局单例模式管理呢？在这种模式下，我们的组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！&emsp;另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，我们的代码将会变得更结构化且易维护。安装：1npm install vuex --save 原理：使用：在main.js文件中配置创建的store仓库（文件夹）]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Hexo博客初体验]]></title>
    <url>%2F2018%2F06%2F02%2F%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[摘要：这是一篇关于小白如何使用Github Pages和Hexo搭建属于自己的博客： 如何使用和配置Hexo框架 如何将Hexo部署到自己的github项目中 前言：很久之前早就想弄一个自己的博客，但是迟迟没有落实，大概是一直没有找到自己想要的那种博客（借口~），今天看了stormzhang公众号的一篇文章《我为什么坚持写博客？》推荐的hexo，上网了解了下发现这大概就是我想要的吧~经过一下午折腾终于搭建属于自己的博客，我觉得很有必要把整个过程写下来分享给大家互相学习使用。不废话了直奔主题！ 一、环境配置安装node.js 下载node.js选择自己电脑版本的本人是windows 64位，直接傻瓜式下载使用即可 安装git 下载git同样是根据电脑版本下载 下载完成，通过在命令行输入 git version 查看是否安装成功，有输出版本号说明安装成功。 鼠标邮件菜单里就多了Git GUI Here和Git Bash Here两个按钮，一个是图形界面的Git操作，一个是命令行，我们选择Git Bash Here。 二、Hexo安装①桌面鼠标右键，选择Git Bash Here，输入下面命令： npm install -g hexo-cli 如果出现说明hexo已经安装成功（针对windows） ②然后需要创建一个文件夹来存放hexo文件（相当于你的博客文件夹）例如：我在电脑上手动创建了一个名叫blog的文件夹，然后需要执行以下命令初始化： hexo init e:\blog 进入该目录： cd e:\blog 执行以下命令，系统会可以根据package.json文件中dependencies的配置安装所有依赖包： npm install 然后生成部署文件，启动本地服务 1.hexo g # hexo generate, 生成静态文件 2.hexo s # hexo server，可以在http://localhost:4000/ 查看 其他hexo命令用法可参考 Hexo官网 接下来我们可以在本地预览自己的博客了，打开http://localhost:4000/ 三、Github Pages配置顾名思义需要一个Github账号，然后创建一个仓库： 注意：仓库的名字必须是username/username.github.io注意：仓库的名字必须是username/username.github.io注意：仓库的名字必须是username/username.github.io例如：我的用户名为jefff8,那么Repository name必须命名为：jefff8.github.io重要的事情说三遍！！！（当初踩过的坑…）配置SSH密钥上传文件需要配置ssh key，所以首先需要检查本机电脑是否已经存在SSH keys，如果存在删除 .ssh文件夹里面的所有文件（如果不存在的忽略这条）然后设置下name和email git config --global user.name &quot;&lt;your name&gt;&quot; git config --global user.email &quot;&lt;your email&gt;&quot;name的名字随便起，email我建议填github同一个邮箱生成SSH密钥输入以下命令生成，邮箱是github里面注册的邮箱，ok回车： ssh-keygen -t rsa -C &quot;XXXXX@qq.com&quot;一路按回车键即可，如果设置了密码请记住。这一步在~/.ssh/下生成了两个文件id_rsa 和 id_rsa.pub获取SSH密钥 $ cat ~/.ssh/id_rsa.pub新建一个key，然后拷贝下生成的keykey粘贴刚刚生成的密钥，title随便起注意：重点圈起来，key下面的√记得一定要打哦！不然后面会报错，又是踩过的坑说多都是泪… 提交后，输入一下命令： ssh git@github.com 如果出现这样的内容： The authenticity of host &apos;github.com (192.30.252.128)&apos; can&apos;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added &apos;github.com,192.30.252.128&apos; (RSA) to the list of known hosts. Hi git-xuhao! You&apos;ve successfully authenticated, but GitHub does not provide shell access. Connection to github.com closed. 大致恭喜你配置成功！！这时钥匙也变绿啦 四、部署到Github配置_config.yml 编辑刚刚新建的文件夹（e:/blog）根目录内,找到该文件，找到并修改Deployment部分（一般在最后） 注意：在每个填入前加个空格(否则会有错误)，其中repository填的是刚刚github新建仓库的SSH地址。 安装Git包，执行以下命令： npm install hexo-deployer-git --save cd到根目录，执行以下命令即可： hexo g hexo d now，你可以输入https://username.github.io来访问自己的博客啦（开森）！！！ 五、关于Hexo使用①更换主题 可以进入Hexo官网主题专栏找到自己想要的主题（个人强推：next） 找到想要的然后到克隆主题啦，十分简单，复制github地址输入一下命令： git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) 成功后，你会发现themes文件夹里面多了一个注意文件夹 然后修改下根目录配置文件_config.yml里面的theme：主题名字（主题文件夹名字相同） 重新部署主题，Git Bash cd到根目录，输入一下命令： hexo g hexo s #本地预览 如果满意，就可以输入一下命令上传： hexo d ②新建博客文章 新建一篇文章(md文件)输入以下命令： hexo n &quot;文章标题&quot; 然后会在根目录/source/_posts 下生成你的文章文件，打开编辑器编辑就好（本人使用：MarkdownPad 2） 编写好后只要执行： hexo d -g 就会更新我们的Github库。 有关更多配置使用问题，可以参考Hexo官网文档 ~]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
</search>
